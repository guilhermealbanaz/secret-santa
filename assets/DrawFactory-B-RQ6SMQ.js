var x=Object.defineProperty;var R=(a,t,e)=>t in a?x(a,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):a[t]=e;var o=(a,t,e)=>R(a,typeof t!="symbol"?t+"":t,e);import{d as w,f as p,g as S,s as I,o as N}from"./FirebaseService-DgJoARNt.js";class P{constructor(t){o(this,"_value");if(!this.isValid(t))throw new Error("Invalid email format");this._value=t}isValid(t){return!t||typeof t!="string"?!1:/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(t)}get value(){return this._value}equals(t){return this._value===t.value}toString(){return this._value}}class y{constructor(t){o(this,"_value");if(!this.isValid(t))throw new Error("Invalid name");this._value=t.trim()}isValid(t){if(!t||t.trim().length===0)return!1;if(t.trim().length<2)throw new Error("Name must have at least 2 characters");if(t.trim().length>100)throw new Error("Name cannot have more than 100 characters");return!0}equals(t){return this._value.toLowerCase()===t.value.toLowerCase()}get value(){return this._value}}class m{constructor(t){o(this,"_value");this._value=t||this.generate()}generate(){return Math.random().toString(36).substr(2,9)}equals(t){return this._value===t.value}get value(){return this._value}}class h extends Error{constructor(t){super(t),this.name=this.constructor.name}}class g extends h{constructor(t,e){super((e==null?void 0:e.message)||`Error in draw operation: ${t}`)}}class V extends g{constructor(){super("Draw has not been performed yet")}}class O extends g{constructor(){super("Minimum of 3 participants required to perform the draw")}}class v extends g{constructor(t){super(`Draw with ID ${t} not found`)}}class b extends h{constructor(t,e){super((e==null?void 0:e.message)||`Error in participant operation: ${t}`)}}class D extends b{constructor(t){super(`Participant with ID ${t} not found`)}}class E extends h{constructor(t){super(`Validation error: ${t}`)}}class C extends E{constructor(){super("Invalid password or does not match draw password")}}class f extends h{constructor(t,e){super(`Database error in operation ${t}: ${e.message}`)}}class l{constructor(t,e,s){o(this,"_id");o(this,"_name");o(this,"_email");try{new m(t),new y(e),new P(s),this._id=t,this._name=e,this._email=s}catch(r){throw new E(r.message)}}get id(){return this._id}get name(){return this._name}get email(){return this._email}static create(t,e){return new l(new m().value,t,e)}equals(t){return this._id===t.id}toJSON(){return{id:this._id,name:this._name,email:this._email}}static fromJSON(t){return new l(t.id,t.name,t.email)}}class c{constructor(t,e,s,r=[],i={},n=!1,u=new Date,d=!1){this.id=t,this.name=e,this.password=s,this.participants=r,this.result=i,this.performed=n,this.creationDate=u,this.configured=d}setName(t){return new c(this.id,t.value,this.password,this.participants,this.result,this.performed,this.creationDate,this.configured)}setPassword(t){return new c(this.id,this.name,t.value,this.participants,this.result,this.performed,this.creationDate,this.configured)}performDraw(){if(this.participants.length<4)throw new Error("Minimum of 4 participants required");const t=[...this.participants].sort(()=>Math.random()-.5),e={};return t.forEach((s,r)=>{const i=(r+1)%t.length;e[s.email]=t[i].email}),new c(this.id,this.name,this.password,this.participants,e,!0,this.creationDate,this.configured)}checkPassword(t){return this.password===t.value}findSecretFriend(t){const e=this.result[t.email];return this.participants.find(s=>s.email===e)||null}static fromJSON(t){return new c(t.id,t.name||"",t.password||"",(t.participants||[]).map(e=>new l(e.id,e.name||"",e.email||"")),t.result||{},t.performed||!1,t.creationDate?new Date(t.creationDate):new Date,t.configured||!1)}toJSON(){return{id:this.id,name:this.name,password:this.password,participants:this.participants?this.participants.map(t=>({id:t.id,name:t.name,email:t.email})):[],result:this.result||{},performed:this.performed||!1,creationDate:this.creationDate.toISOString(),configured:this.configured||!1}}}class F{async perform(t){if(t.participants.length<2)throw new Error("Insufficient participants");const e=[...t.participants],s={};for(let r=e.length-1;r>0;r--){const i=Math.floor(Math.random()*(r+1));[e[r],e[i]]=[e[i],e[r]]}for(let r=0;r<e.length;r++){const i=e[r],n=e[(r+1)%e.length];s[i.email]=n.email}return new c(t.id,t.name,t.password,t.participants,s,!0)}}class ${constructor(){o(this,"collection","draws")}async findById(t){try{const e=w(p,this.collection,t),s=await S(e);return s.exists()?c.fromJSON({id:s.id,...s.data()}):null}catch(e){throw new f("getById",e)}}async update(t){try{const e=w(p,this.collection,t.id),s={id:t.id,name:t.name,password:t.password,participants:t.participants?t.participants.map(r=>({id:r.id,name:r.name,email:r.email})):[],result:t.result||{},performed:t.performed||!1,creationDate:t.creationDate?t.creationDate.toISOString():new Date().toISOString(),configured:t.configured||!1};await I(e,s,{merge:!0})}catch(e){throw console.error("Erro ao atualizar:",e),new f("update",e)}}observe(t,e){try{const s=w(p,this.collection,t);return N(s,r=>{if(r.exists()){const i=r.data(),n=c.fromJSON({id:r.id,...i});e(n)}})}catch(s){throw console.error("Erro ao observar:",s),new f("observe",s)}}}class q{constructor(t){this.drawRepository=t}async execute(t,e){const s=await this.drawRepository.findById(t);if(!s)throw new v(t);const r=new y(e),i=s.setName(r);await this.drawRepository.update(i)}}class J{constructor(t){this.drawRepository=t}async execute(){const t=new m().value,e=new c(t,"","",[],{},!1);return await this.drawRepository.update(e),t}}class _{constructor(t){o(this,"_value");if(!this.isValid(t))throw new Error("Invalid password");this._value=t}isValid(t){if(!t||t.trim().length===0)return!1;if(t.length<4)throw new Error("Password must have at least 4 characters");if(t.length>50)throw new Error("Password cannot have more than 50 characters");return!0}equals(t){return this._value===t.value}get value(){return this._value}}class M{constructor(t){this.drawRepository=t}async execute(t,e){const s=await this.drawRepository.findById(t);if(!s)throw new v(t);if(s.participants.length<4)throw new O;const r=new _(e),i=s.performDraw().setPassword(r);await this.drawRepository.update(i)}}class B{constructor(t){this.drawRepository=t}async execute(t,e,s){const r=await this.drawRepository.findById(t);if(!r)throw new v(t);if(!r.performed)throw new V;const i=new _(s);if(!r.checkPassword(i))throw new C;const n=r.participants.find(d=>d.id===e);if(!n)throw new D(e);const u=r.findSecretFriend(n);if(!u)throw new D("secret friend");return{participant:n,secretFriend:u}}}class L{static createService(){return new F}static createRepository(){return new $}static async createUseCases(){const t=this.createRepository();return{configure:new q(t),create:new J(t),perform:new M(t),viewResult:new B(t)}}}export{L as D,l as P,E as V,c as a,h as b};
